# Item17: 변경 가능성을 최소화하라

요약: 불변 객체를 사용하라 (모든 필드에 **private final** 을 붙여라)

- 불변 "객체"를 위해서 언어마다 다양한 문법을 제공한다.
- 이펙티브 자바에서는 불변 "클래스" 를 통해 만들라고 한다.
- 개인적으로 불변 객체를 가장 잘 활용하는 것은 함수형 언어라고 생각한다.
    - 기회가 되면 haskell 을 배워보자

![haskell](./img/haskell.png)

## 불변 객체를 사용하는 이유

객체가 "불변" 한다.
<br> -> 객체의 상태를 변경할 수 없다. {state:상태, property, attribute:속성, member:멤버, 언어마다 부르는게 다름}
<br> -> 변경 가능성이 최소화 된다. (사실 변경이 그냥 가능하지가 않다.)
<br> -> sideeffect 가 최소화 된다.

## 불변 객체를 사용해야 할 때

모든 클래스를 불변 클래스로 구현하려 하면, 머리가 터진다.
<br> 오죽하면 xkcd 에서 haskell 을 아무도 안 쓴다고 자조하겠는가...
<br> 그럼에도 **VO(Value Object)** 는 반드시 불변 객체로 구현하자고 주장을 한다.
<br> 왜냐하면, 상태가 변경되는 메서드가 있다는 것은 VO 에 로직이 있다는 소리인데, 그 순간 VO 는 VO 가 아니기 때문이다.
<br> VO 가 불변 객체가 아니라면, 자신이 설계를 이상하게 한 것은 아닌지 점검할 필요가 있다.

자주 접하게 되는 대표적인 VO 로 DTO 가 있다.
<br> 개인 경험상 DTO 의 상태를 변경하려 하는 경우는 전처리 혹은 후처리를 하려 할 경우이다.
<br> 그럴 경우에는 전처리 혹은 후처리를 하는 부분을 별도의 layer 로 분리하고  (다행히 Spring 에는 Interceptor 가 있다.)
<br> 해당 layer 에서 새로운 layer 에 맞는 DTO 클래스를 새롭게 정의해서, 새로운 객체를 만들도록 하자

### 불변 객체 면접 대비

"불변 객체가 무엇이고, 왜 사용하는가?" 이거 면접 문제로 꽤 자주 나온다.

<br> 가장 짧은 답은 **"race condition"** 이다.
<br> 만약 이 보다 더 깊은 설명을 요구한다면,
<br> **"불변 객체를 사용하면 공유 자원의 critical section 에서 synchronize 를 해줄 필요가 없게 된다"**
<br> 라고 답을 하자.
<br> 왜 필요가 없냐고 되묻는다면,
<br> **"객체의 상태가 변경되지 않기 때문에, 그로인한 sideeffect 가 발생하지 않기 때문이다."**
<br> 라고 답을 해주자.

<br> 이 이후에는 불변 객체로 발생할 수 있는 문제점을 지적한다.
<br> "불변 객체를 사용하면, 끊임없이 객체의 생성과 GC 가 일어나는데, 이로 인한 성능 저하는 어떻게 개선할 것인가?"
<br> 여러가지 답이 있겠지만, 나는 **"캐싱"** 을 하자고 제안한다.
<br> 필요한 불변 객체들의 pool 을 만들고, 동일한 상황을 key 로 표현해서 재활용할 수 있도록 한다.
<br> 또한 synchronize 로 인한 병목이, 불변 객체로 인한 성능저하보다 훨씬 클 수 있음을 지적하자.

## 불변 클래스 만드는 법

책에 여러가지가 나오는데, **"private"** 과 **"final"** 만 기억하면 될 것 같다.

- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다. (클래스를 final 로 선언한다.)
- 모든 필드를 final 로 선언한다.
- 모든 필드를 private 으로 선언한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. (접근하게 되면 꼭 방어적 복사를 하자.)


## 예시 코드

statement 를 배제하고 expression 만을 사용하면 자동으로 불변이 된다.
<br>잘 모르겠다면, Rx 시리즈를 배워보자. (RxJava, RxJS, RxSwift)

이펙티브 자바의 예시코드에 대해 작가 본인이 "이 클래스는 불변을 설명하기 위한 예로 든 것일 뿐, 실무에서 쓸 만한 수준은 못 된다." 라고 말했기 때문에, 이펙티브 자바의 코드 말고 새로 작성을 해보았다.

### 조건문

#### 가변 코드

```java
int num 1;
if (true) {
    num = 2;
}
```

#### 불변 코드

```java
final int num = true ? 1 : 2;
```

### 반복문

#### 가변 코드

```java
int sum = 0;
for (int i = 0; i < 100; i++) {
    sum += i;
}
```

#### 불변 코드

```java
final int sum = IntStream.range(0, 100).sum()
```

## Tip

책에서 "BigInteger 와 BigDecimal 을 설계할 당시엔 불변 객체가 사실상 final 이어야 한다는 생각이 널리 퍼지지 않았다." 라고 한다.
<br> 매우 끔찍하지만, "가변이라 가정하고 방어적으로 복사해 사용해야 한다" 를 따르도록 하자

## 결론

함수형으로 프로그래밍하면 자연스럽게 불변 객체를 사용해서 구현하게 된다.

다만 자바는 객체지향 프로그래밍 언어라서, 불변 클래스를 통해 강제를 해줄 필요성이 있다.

어렵게 생각하지 말고, 클래스 안의 멤버앞에 **private** 과 **final** 을 붙여주자.

그리고 정말로 어쩔 수 없을 때만 final 을 제거하자.

final 을 제거할 때에는 충분한 설계와 고민이 뒷받침 되어야한다.
